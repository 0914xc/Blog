---
title: 观察者模式
date: 2022-05-07 20:53:14
categories: 设计模式
---
观察者模式又叫做发布-订阅（Publish/Subscribe）模式、源-监听（Source/Listener）模式。它定义了一种**一对多**的依赖关系，一个主题，多个观察者，当主题发生变化的时候，会**主动**的通知观察者，这样观察者便能针对主题发生的变化，执行某些对应的动作。

实现该模式通常需要两个过程：**订阅者订阅、发布者发布**

```java
/**
 * 主题，也是被观察者
 */
public interface Observable {
    
    /**
     * 添加观察者
     */
    void addObsrver(Observer observer);
    
    /**
     * 删除观察者
     */
    void deletebserver(Observer observer);
    
    /**
     * 事件发生，通知观察者
     */
    void notifybservsers();
}
```

```java
/**
 * 观察者
 */
public interface Observer {
    /**
     * 
     * @param observable
     * @param arg
     */
    void update(Observable observable, Object arg);
}
```

以Tomcat中Lifecycle为例，我们这里简单模仿一下，实现上面的两个接口。
```java
/**
 * 主题的具体实现
 */
public class Container implements Observable {
    
    /**
     * 观察者列表
     */
    private List<Observer> observers = new ArrayList<>();
    
    /**
     * 添加观察者
     */
    void addObsrver(Observer observer) {
        observers.add(observer);
    }
    
    /**
     * 删除观察者
     */
    void deletebserver(Observer observer) {
        observers.remove(observer);
    }
    
    /**
     * 事件发生，通知观察者
     */
    void notifybservsers() {
        for (Observer observer : observers) {
            observer.update(this, "container start");
        }
    }
}
```

```java
/**
 * 观察者的具体实现
 */
public class ContainerConfig implements Observer {
    /**
     * 
     * @param observable
     * @param arg
     */
    void update(Observable observable, Object arg) {
        String event = (String) arg;
        if (event.equals("container start")){
            // do container configs
        }
    }
}
```

实际上，监听器模式也是如此，观察者相当于事件的监听者，被观察者相当于事件和事件源，事件源经过事件的封装传给监听器，当事件源触发事件后，监听器接收到事件对象可以回调事件的方法。

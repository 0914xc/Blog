---
title: 责任链模式
date: 2022-05-07 20:53:14
categories: 设计模式
---
### 定义
为了避免请求发送者与多个请求处理者耦合在一起，于是将所有请的处理者**通过前一对象记住其下一个对象的引用，而链成一条链**，当有请求发生时，可将请求沿着这条链传递，直到有对象处理它为止。

特点：

1. 满足开闭原则，可以根据需求增加新的请求处理类。
1. 符合单一职责原则，每个类只需要处理自己该处理的工作。

### 模式的结构与实现

> 责任链模式的本质是解耦请求与处理，让请求在处理链中能进行传递与被处理。理解责任链模式应当理解其模式，而不是其具体实现。责任链模式的独到之处是将其节点处理者组合成了链式结构，并允许节点自身决定是否进行请求处理或转发，相当于让请求流动起来。


**抽象处理者 Handler**
定义一个处理请求的接口，包含抽象处理方法和一个后继链接
```java
abstract class Handler {
    private Handler next;
    
    public void setNext(Handler next) {
        this.next = next;
    }
    
    public Handler getNext() {
        return next;
    }
    
    // 处理请求的方法
    public abstract void handleRequest(String request);
}
```

**具体处理者 Concrete Handler**
实现抽象处理者的处理方法，判断能否处理本次请求，如果可以处理则处理，否则将该请求转给它的后继者。
```java
class ConcreteHandlerOne extends Handler {
    public void handleRequest(String request) {
        if (request.equals("one")) {
            System.out.println("ConcreteHandlerOne处理请求。");
        } else {
            if (getNext() != null) {
                getNext().handleRequest(request);
            } else {
                System.out.println("没有节点处理该请求")
            }
        }
    }
}

class ConcreteHandlerTwo extends Handler {
    public void handleRequest(String request) {
        if (request.equals("two")) {
            System.out.println("ConcreteHandlerTwo处理请求。");
        } else {
            if (getNext() != null) {
                getNext().handleRequest(request);
            } else {
                System.out.println("没有节点处理该请求")
            }
        }
    }
}
```

**客户类 Client**
创建处理链，并向链头的具体处理者对象提交请求，它不关心处理细节和请求的传递过程。
```java
class Client {
    public static void main(String[] args) {
        // 创建处理链
        Handler handlerOne = new ConcreteHandlerOne();
        Handler handlerTwo = new ConcreteHandlerTwo();
        handlerOne.setNext(handlerTwo);
        
        // 向链头提交请求
        handlerOne.handleRequest("two");
    }
}
```
